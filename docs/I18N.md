# Internationalization (i18n) Backend Implementation

## Overview

This API implements a hybrid i18n approach optimized for frontend-backend separation:

- **API responses**: Return error codes (not localized messages) for the client to translate
- **Server-generated content**: Use localization for emails, notifications, PDFs, and reports
- **Language support**: French (fr) and English (en)

## Architecture

### 1. Error Response Structure

All API errors return a standardized `ApiErrorResponse` object:

```json
{
  "errorCode": "FURNITURE_NOT_FOUND",
  "message": "Furniture not found",
  "details": { ... }
}
```

- `errorCode`: A constant that the frontend maps to localized messages
- `message`: English message for debugging (NOT for end-users)
- `details`: Optional additional information

### 2. Error Codes

Standard error codes are defined in `Models/ErrorCodes.cs`:

- `FURNITURE_NOT_FOUND`
- `LOCATION_NOT_FOUND`
- `RFID_TAG_NOT_FOUND`
- `FILE_NOT_PROVIDED`
- `INVALID_FILE_FORMAT`
- `VALIDATION_ERROR`
- `ID_MISMATCH`
- `OPERATION_FAILED`
- `IMPORT_ERROR`
- etc.

### 3. Server-Side Localization

For server-generated content (emails, notifications, etc.), use `IStringLocalizer<SharedResources>`:

```csharp
public class MyController : ControllerBase
{
    private readonly IStringLocalizer<SharedResources> _localizer;
    
    public MyController(IStringLocalizer<SharedResources> localizer)
    {
        _localizer = localizer;
    }
    
    public IActionResult SendNotification()
    {
        var message = _localizer["Notification.FurnitureAdded"].Value;
        // Use message for email/notification
    }
}
```

### 4. Resource Files

Translations are stored in `.resx` files:

- `Resources/SharedResources.resx` (English - default)
- `Resources/SharedResources.fr.resx` (French)

Resource keys follow the pattern: `Category.Key`
- `Email.Welcome.Subject`
- `Email.Welcome.Body`
- `Notification.FurnitureAdded`
- `Server.FileValidation.Valid`

## Language Selection

The API respects language preferences in this order:

1. **Query string**: `?culture=fr`
2. **Cookie**: `.AspNetCore.Culture`
3. **Accept-Language header**: Sent by the browser

Example requests:

```bash
# Using Accept-Language header
curl -H "Accept-Language: fr" https://api.example.com/api/furniture

# Using query string
curl https://api.example.com/api/furniture?culture=fr
```

## Configuration

### appsettings.json

```json
{
  "Localization": {
    "DefaultCulture": "en",
    "SupportedCultures": ["en", "fr"]
  }
}
```

### Program.cs

The localization middleware is configured in `Program.cs`:

```csharp
builder.Services.AddLocalization(options => options.ResourcesPath = "Resources");

// Configure supported cultures
var supportedCultures = new[]
{
    new CultureInfo("en"),
    new CultureInfo("fr")
};

builder.Services.Configure<RequestLocalizationOptions>(options =>
{
    options.DefaultRequestCulture = new RequestCulture("en");
    options.SupportedCultures = supportedCultures;
    options.SupportedUICultures = supportedCultures;
});
```

## Frontend Integration

The frontend should:

1. **Map error codes to localized messages**:

```javascript
const errorMessages = {
  en: {
    FURNITURE_NOT_FOUND: "Furniture not found",
    INVALID_FILE_FORMAT: "Invalid file format. Use .xlsx, .xls or .csv"
  },
  fr: {
    FURNITURE_NOT_FOUND: "Meuble non trouvé",
    INVALID_FILE_FORMAT: "Format de fichier invalide. Utilisez .xlsx, .xls ou .csv"
  }
};

// In error handler
const errorCode = response.data.errorCode;
const localizedMessage = errorMessages[currentLanguage][errorCode];
```

2. **NOT display the `message` field** from API responses (it's for debugging only)

3. **Handle the `details` object** for additional context (field names, validation errors, etc.)

## Adding New Translations

### 1. Add Error Code

Add to `Models/ErrorCodes.cs`:

```csharp
public const string NEW_ERROR = "NEW_ERROR";
```

### 2. Add Server-Side Translation

Add to both `.resx` files:

**SharedResources.resx** (English):
```xml
<data name="Category.NewKey" xml:space="preserve">
  <value>English message</value>
</data>
```

**SharedResources.fr.resx** (French):
```xml
<data name="Category.NewKey" xml:space="preserve">
  <value>Message en français</value>
</data>
```

### 3. Frontend Translation

Add to frontend translation files:

```json
{
  "en": { "NEW_ERROR": "English error message" },
  "fr": { "NEW_ERROR": "Message d'erreur en français" }
}
```

## Testing Localization

### Test Accept-Language Header

```bash
# English (default)
curl http://localhost:8080/api/Import/default

# French
curl -H "Accept-Language: fr" http://localhost:8080/api/Import/default
```

### Test Query String

```bash
curl http://localhost:8080/api/Import/default?culture=fr
```

## Best Practices

1. **Always return error codes** in API responses, never hardcoded messages
2. **Use IStringLocalizer** only for server-generated content (emails, PDFs, notifications)
3. **Keep error codes consistent** between backend and frontend
4. **Don't translate business data** (furniture names, locations, etc.) - only UI messages
5. **Test with different locales** to ensure proper fallback behavior

## Future Enhancements

- Add more languages as needed
- Implement ICU MessageFormat for complex pluralization
- Add translation management system (TMS) integration
- Add CI checks for missing translation keys
